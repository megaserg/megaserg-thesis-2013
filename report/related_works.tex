\section{Обзор существующих подходов}

Сборка программного проекта~--- неотъемлемая часть процесса промышленного программирования. Для автоматизации и оптимизации процесса сборки научным и профессиональным сообществами были разработаны различные подходы.

\subsection{Утилита \texttt{make}}
\texttt{make}\footnote{Подробнее о \texttt{make} можно прочитать на Википедии: \url{http://ru.wikipedia.org/wiki/Make}}~--- утилита, автоматизирующая процесс преобразования файлов из одной формы в другую. Чаще всего это компиляция исходного кода в объектные файлы и последующая компоновка (linking) в исполняемые файлы или библиотеки. \texttt{make}~--- одна из самых широко распространённых утилит для отслеживания зависимостей, в значительной степени благодаря её включению в ОС Unix и ОС семейства BSD. Программа была создана Стюартом Фельдманом (Stuart Feldman) в 1977 году и описана в его работе~\cite{feldman_make}. Существует несколько версий \texttt{make}, основанных на оригинальной \texttt{make} или написанных с нуля, использующих те же самые форматы файлов и базовые принципы и алгоритмы, а также содержащие некоторые улучшения и расширения.

Утилита использует специальные \texttt{make}-файлы, в которых указаны зависимости файлов друг от друга и правила, определяющие действия для удовлетворения этих зависимостей. Решение о том, нужно ли перегенерировать целевые файлы (targets), принимается на основе информации о времени последнего изменения каждого файла. Если время последнего изменения исходных файлов или файлов-зависимостей больше соответствующего времени изменения целевых файлов, то \texttt{make} определяет и запускает необходимые программы для перегенерации целевых файлов, иначе сгенерированные ранее целевые файлы считаются актуальными (up-to-date). Таким образом, за счёт того, что избыточные перегенерации не производятся, экономятся вычислительные ресурсы.

Однако в случаях, когда файл меняется, а его время изменения остаётся в прошлом (т.е. предшествует текущему моменту), такой подход даёт сбой, и пользователь должен принудительно запустить полную перекомпиляцию. Примерами таких случаев могут служить восстановление более старой версии исходного файла или ситуация, когда файлы находятся на сетевой файловой системе, чьё локальное время не синхронизировано с машиной, на которой запускается \texttt{make}. Соответственно, если время последнего изменения файла оказалось в будущем, то это вызовет избыточную перекомпиляцию. Кроме того, перекомпиляция (тоже, разумеется, избыточная) будет произведена, даже если изменение состояло, например, в модификации комментария внутри исходного файла.

В работе~\cite{safeness_niels} предпринята попытка формализовать подход к сборке, реализуемый утилитой \texttt{make}. Анализируется проблема безопасности использования \texttt{make} для инкрементальной компиляции как альтернативы полной сборке (brute-force build). Безопасность (safeness) инкрементальной компиляции формулируется следующим образом: пусть была произведена полная сборка, затем исходные файлы (и, возможно, \texttt{make}-файл) были изменены; тогда при выполнении некоторых условий результат произведённой после этого основанной на \texttt{make} инкрементальной компиляции эквивалентен результату повторной полной сборки, если бы такая была произведена. С целью формулировки этих условий для \texttt{make} строится семантическая модель. Ключевым результатом работы является сформулированный набор критериев, которым должны удовлетворять правила \texttt{make}-файла, чтобы обеспечить вышеупомянутую безопасность. Помимо этого, установлены условия, при которых \texttt{make}-файл может быть модифицирован с сохранением свойства безопасности.

Хотя сформулированные критерии и являются довольно интуитивными, полученный результат представляет собой формальное обоснование существующей практики использования \texttt{make}. Кроме того, показано, что на основанную на \texttt{make} инкрементальную компиляцию можно полагаться и в некоторых неочевидных ситуациях, например, при определённых модификациях \texttt{make}-файла.\\

\subsection{Инкрементальная компиляция в IntelliJ IDEA}
IntelliJ IDEA\footnote{Страница IDEA на сайте JetBrains: \url{http://www.jetbrains.com/idea/}}~--- интегрированная cреда разработки программного обеспечения на многих языках программирования (в частности, Java), разработанная компанией JetBrains. Помимо полной перекомпиляции проекта (пункт меню ``Rebuild Project''), IDEA предоставляет возможность инкрементальной компиляции (пункт меню ``Make Project''), при произведении которой компилируются только файлы, которые были изменены с момента последней компиляции (с учётом соответствующих зависимостей, вычисляемых автоматически)\footnote{\url{http://www.jetbrains.com/idea/webhelp/compilation-types.html}}. Начиная с 12-й версии поддерживается ``external build''~--- выполнение задач компиляции в отдельном процессе, независимом от основного процесса IDE\footnote{\url{http://blogs.jetbrains.com/idea/2012/12/intellij-idea-12-compiler-twice-as-fast/}}.

В текущей реализации инкрементальной компиляции в IntelliJ IDEA используется локальное кэширование, изменения файлов отслеживаются по временным меткам (timestamps)~--- для каждого файла запоминается время его самого позднего изменения на момент последней компиляции, и файл считается изменившимся, если фактическое время его самого позднего изменения не совпадает с запомненным. Отслеживание осуществляется с помощью виртуальной файловой системы (Virtual File System), поддерживающей моментальные снимки (snapshots) содержимого жёсткого диска пользователя\footnote{\url{http://confluence.jetbrains.com/display/IDEADEV/IntelliJ+IDEA+Virtual+File+System}}. В кэше хранятся абсолютные пути к файлам, таким образом, при перемещении проекта или его части в другую директорию накопленный кэш теряется.

\subsection{Инкрементальная компиляция в Eclipse}
Eclipse\footnote{Подробнее об Eclipse можно прочитать на Википедии: \url{http://ru.wikipedia.org/wiki/Eclipse}}~--- свободная интегрированная среда разработки, развиваемая и поддерживаемая Eclipse Foundation. На основе Eclipse Platform разрабатываются IDE для различных языков программирования, в том числе наиболее популярная из них~--- Eclipse Java IDE.
Eclipse Platform различает полную (full build) и инкрементальную сборки (incremental build). Инкрементальные сборки проектов намного быстрее полных потому, что для компиляции рассматриваются только те исходные ресурсы, которые изменились со времени последней компиляции.
Инкрементальный сборщик вызывается каждый раз, когда сохраняется файл. Отмечается, что во многих компиляторах непосредственно на саму компиляцию тратится довольно мало времени; большая часть времени тратится на разрешение контекста (context resolving). Для улучшения производительности последовательных сеансов компиляции рекомендуется сохранять информацию о контексте после компиляции\footnote{\url{http://wiki.eclipse.org/FAQ_How_do_I_make_my_compiler_incremental?}}.

Eclipse и IntelliJ IDEA по-разному подходят к процессу компиляции. В частности, Eclipse использует свой собственный компилятор Java (Eclipse Compiler for Java, ECJ), отличающийся от классического компилятора \texttt{javac}. Этот компилятор позволяет генерировать класс-файлы даже для исходных файлов, содержащих ошибки, то есть таких, на которых классический \texttt{javac} завершился бы аварийно и не сгенерировал бы ничего. Эти класс-файлы требуются среде Eclipse для построения в фоновом режиме синтаксического дерева (AST) и обеспечения соответствующей функциональности, требуемой от IDE. Кроме того, такой подход позволяет автоматически, без прямой команды пользователя, в фоновом режиме компилировать исходные файлы при их изменениях (``automake''), возможно, обнаруживая при этом ошибки и сообщая о них пользователю, а также (при использовании соответствующего режима) запускать класс-файлы, полученные при компиляции исходного кода, содержащего ошибки.
Среде IDEA для построения синтаксического дерева не требуются скомпилированные классы, поэтому компилятор используется только для порождения исполняемых класс-файлов. Для этой цели может использоваться как классический компилятор \texttt{javac}, так и компилятор Eclipse. Функциональность ``automake'' также поддерживается, независимо от того, какой компилятор используется\footnote{Комментарий разработчика подсистемы компиляции IDEA: \url{http://blogs.jetbrains.com/idea/2012/06/brand-new-compiler-mode-in-intellij-idea-12-leda/#comment-272265}}.

Как и IntelliJ IDEA, Eclipse отслеживает изменения файлов по временным меткам, и, следовательно, подвержен тем же проблемам, связанным с системами контроля версий и рассинхронизацией времени на разных компьютерах.

\subsection{Инструмент \texttt{ccache}}
\texttt{ccache}\footnote{Сайт инструмента \texttt{ccache}: \url{http://ccache.samba.org/}}~--- это инструментальное средство разработки программного обеспечения, которое кэширует порождения C/C++ компиляции, так чтобы в следующий раз компиляции с теми же самыми параметрами и входными данными можно было избежать и взять результаты из кэша. Это позволяет значительно ускорить время перекомпиляции. Обнаружение повторов производится с помощью хэширования различных видов информации, которая должна быть уникальной для сеанса компиляции, и последующего использования хэш-сумм для идентификации кэшированных порождений. Поддерживаются языки C, C++, Objective-C и Objective-C++. Гарантируется, что такой подход безопасен (safe): важнейший аспект кэша компиляции~--- всегда возвращать в точности те же самые порождения, которые вернул бы настоящий компилятор. Это включает в себя предоставление точно тех же объектных файлов и предупреждений компиляции, которые были бы выданы настоящим компилятором.
Одной из возможностей \texttt{ccache} является совместное использование кэша. Группа разработчиков может увеличить hit rate кэша, совместно используя директорию, в которой он хранится. С этой целью возможно расположить кэш-директорию на сетевой файловой системе NFS (или другой файловой системе подобного рода).

\subsection{Инструмент Amake}
В работах~\cite{amake2012, amake2013} предлагается модификация утилиты \texttt{make} под названием Amake, реализующая подход, при котором система сборки, основанная на \texttt{make}-файлах (Makefile-based build system), улучшается с помощью автоматического анализа зависимостей. Помимо стандартных зависимостей между файлами (а именно, зависимостей целевых файлов от исходных и других целевых), отслеживаются следующие зависимости: команды оболочки ОС (shell), используемые для генерации целевых файлов; программы, исполнение которых предписывается правилами; библиотеки общего пользования (shared libraries), используемые программами, упомянутыми в правилах; переменные окружения (environment variables). Вместо временных меток для определения изменившихся зависимостей используются подсчитываемые для файлов хэш-суммы. Также хэш-суммы подсчитываются для содержимого правил, а также для исполняемых файлов упоминаемых в них программ, с помощью чего отслеживаются их изменения. Для автоматического отслеживания изменившихся файловых зависимостей применяется перехват вызовов методов (таких как \texttt{open}) стандартной библиотеки C (Standard C Library); для этого используется переменная окружения \texttt{LD\_PRELOAD}, что сужает область применения Amake до Unix-подобных ОС. В архитектуре выделяется кэш, в котором хранятся целевые файлы, порождённые предыдущими сеансами компиляции. Содержимое кэша предлагается хранить на сетевом NFS-диске, а индекс~--- в реляционной базе данных. Это допускает одновременное использование системы несколькими разработчиками. Отмечается, что использование хэш-сумм лишь незначительно медленнее сравнения временных меток.\\

\subsection{Выводы}
Для решения задачи сокращения времени сборки программного проекта разработчиками применяются различные методы. Среди них отказ от произведения компиляции, если исходный код не изменился с момента предыдущего сеанса компиляции; сохранение сгенерированных порождений в специальном хранилище-кэше с индексацией, основанной на временных метках или хэшах; оптимистический подход, который состоит в компиляции исходного кода не по команде пользователя, а по мере изменения файлов, в фоновом режиме.

В рассматриваемой в данной работе задаче фигурируют несколько разработчиков, а значит, несколько компьютеров. В такой ситуации временные метки в силу их относительности использовать нельзя. Предлагается вместо временных меток применять хэширование исходных файлов, а именно хэширующую структуру, способную считать контрольные суммы не только на уровне отдельных файлов, но и на уровне директорий и модулей проекта. При этом пути файлов следует также представлять в переносимом, относительном виде, а именно отсчитывать от корневой директории проекта.

Вычислительно ёмким этапом компиляции является разрешение зависимостей. В языке Java зависимости могут быть разного рода~--- использование имени класса, определённого в другом файле, вызов метода, использование поля, наследование от класса и пр. При современных масштабах проектов построение графа зависимостей вручную, как это предполагается, например, в \texttt{make}, не представляется возможным, граф должен строиться автоматически.

В рассмотренных работах прослеживаются как попытки формального описания предметной области и построения на этой базе критериев безопасности переиспользования порождений (т.е. намерения определить теоретические границы применимости подхода), так и технические решения, направленные на автоматизацию и ускорение процесса сборки, а также учитывающие переносимость и одновременное участие в проекте нескольких разработчиков. В силу того, что в теоретических построениях в качестве основной системы сборки рассматривается система, основанная на \texttt{make}-файлах, остаётся простор для дальнейших научных исследований: построения более общих формальных систем, а также базирующихся на них технических решений.

\section{Обзор существующих решений}

\subsection{Утилита \texttt{make}}
\texttt{make}\footnote{\url{http://ru.wikipedia.org/wiki/Make}}~--- утилита, автоматизирующая процесс преобразования файлов из одной формы в другую. Чаще всего это компиляция исходного кода в объектные файлы и последующая компоновка (linking) в исполняемые файлы или библиотеки. \texttt{make}~--- одна из самых широко распространённых утилит для отслеживания зависимостей, в значительной степени благодаря её включению в ОС Unix и ОС семейства BSD. Программа была создана Стюартом Фельдманом (Stuart Feldman) в 1977 году и описана в его работе \cite{feldman_make}. Существует несколько версий \texttt{make}, основанных на оригинальной \texttt{make} или написанных с нуля, использующих те же самые форматы файлов и базовые принципы и алгоритмы, а также содержащие некоторые улучшения и расширения.

Утилита использует специальные \texttt{make}-файлы, в которых указаны зависимости файлов друг от друга и правила, определяющие действия для удовлетворения этих зависимостей. Решение о том, нужно ли перегенерировать целевые файлы (targets), принимается на основе информации о времени последнего изменения каждого файла. Если время последнего изменения исходных файлов или файлов-зависимостей больше соответствующего времени изменения целевых файлов, то \texttt{make} определяет и запускает необходимые программы для перегенерации целевых файлов, иначе сгенерированные ранее целевые файлы считаются актуальными (up-to-date). Таким образом, за счёт избежания избыточных перегенераций экономятся вычислительные ресурсы.

Однако в случаях, когда файл меняется, а его время изменения остаётся в прошлом (т.е. предшествует текущему моменту), такой подход даёт сбой, и пользователь должен принудительно запустить полную перекомпиляцию. Примерами таких случаев могут служить восстановление более старой версии исходного файла или ситуация, когда файлы находятся на сетевой файловой системе, чьё локальное время не синхронизировано с машиной, на которой запускается \texttt{make}. Соответственно, если время последнего изменения файла оказалось в будущем, то это вызовет избыточную перекомпиляцию. Кроме того, перекомпиляция (тоже, разумеется, избыточная) будет произведена, даже если изменение состояло, например, в модификации комментария внутри исходного файла.

\subsection{Инкрементальная компиляция в IntelliJ IDEA}
IntelliJ IDEA\footnote{\url{http://ru.wikipedia.org/wiki/IntelliJ_IDEA}}~--- интегрированная cреда разработки программного обеспечения на многих языках программирования (в частности, Java), разработанная компанией JetBrains\footnote{\url{http://www.jetbrains.com}}. Помимо полной перекомпиляции проекта (пункт меню ``Rebuild Project''), IDEA предоставляет возможность инкрементальной компиляции (пункт меню ``Make Project''), при произведении которой компилируются только файлы, которые были изменены с момента последней компиляции (с учётом соответствующих зависимостей, вычисляемых автоматически)\footnote{\url{http://www.jetbrains.com/idea/webhelp/compilation-types.html}}. Начиная с 12-й версии поддерживается ``external build''~--- выполнение задач компиляции в отдельном процессе, независимом от основного процесса IDE\footnote{\url{http://blogs.jetbrains.com/idea/2012/12/intellij-idea-12-compiler-twice-as-fast/}}.

В текущей реализации инкрементальной компиляции в IntelliJ IDEA используется локальное кэширование, изменение файлов отслеживается по временным меткам (timestamps)~--- для каждого файла запоминается время его самого позднего изменения на момент последней компиляции, и файл считается изменившимся, если фактическое время его самого позднего изменения не совпадает с запомненным. Отслеживание осуществляется с помощью виртуальной файловой системы (Virtual File System), поддерживающей моментальные снимки (snapshots) содержимого жёсткого диска пользователя\footnote{\url{http://confluence.jetbrains.com/display/IDEADEV/IntelliJ+IDEA+Virtual+File+System}}. В кэше хранятся абсолютные пути к файлам, таким образом, при перемещении проекта или его части в другую директорию накопленный кэш теряется. В ситуации, когда разработчиков несколько, временные метки в силу их относительности использовать уже нельзя. Предлагается вместо временных меток применять хэширование исходных файлов, а именно хэширующую структуру, способную считать контрольные суммы не только на уровне отдельных файлов, но и на уровне директорий и модулей проекта.

\subsection{Инкрементальная компиляция в Eclipse}
Eclipse\footnote{\url{http://ru.wikipedia.org/wiki/Eclipse}}~--- свободная интегрированная среда разработки, развиваемая и поддерживаемая Eclipse Foundation. На основе Eclipse Platform разрабатываются IDE для различных языков программирования, в том числе наиболее популярная из них~--- Eclipse Java IDE.
Eclipse Platform различает полную (full build) и инкрементальную сборки (incremental build). Инкрементальные сборки проектов намного быстрее полных, потому что для компиляции рассматриваются только те исходные ресурсы, которые изменились со времени последней компиляции.
Инкрементальный сборщик вызывается каждый раз, когда сохраняется файл. Отмечается, что во многих компиляторах непосредственно на саму компиляцию тратится довольно мало времени; большая часть времени тратится на разрешение контекста (context resolving). Для улучшения производительности последовательных сеансов компиляции рекомендуется сохранять информацию о контексте после компиляции.\footnote{\url{http://wiki.eclipse.org/FAQ_How_do_I_make_my_compiler_incremental?}}

Eclipse и IntelliJ IDEA по-разному подходят к процессу компиляции. В частности, Eclipse использует свой собственный компилятор Java (Eclipse Compiler for Java, ECJ), отличающийся от классического компилятора \texttt{javac}. Этот компилятор позволяет генерировать класс-файлы даже для исходных файлов, содержащих ошибки, то есть таких, на которых классический \texttt{javac} завершился бы аварийно и не сгенерировал ничего. Эти класс-файлы требуются среде Eclipse для построения в фоновом режиме синтаксического дерева (AST) и обеспечения соответствующей функциональности, требуемой от IDE. Кроме того, такой подход позволяет автоматически, без прямой команды пользователя, в фоновом режиме компилировать исходные файлы при их изменениях (``automake''), возможно, обнаруживая при этом ошибки и сообщая о них пользователю, а также (при использовании соответствующего режима) запускать класс-файлы, полученные при компиляции исходного кода, содержащего ошибки.
Среде IDEA для построения синтаксического дерева не требуются скомпилированные классы, поэтому компилятор используется только для порождения исполняемых класс-файлов. Для этой цели может использоваться как классический компилятор \texttt{javac}, так и компилятор Eclipse. Функциональность ``automake'' также поддерживается, независимо от того, какой компилятор используется.\footnote{\url{http://blogs.jetbrains.com/idea/2012/06/brand-new-compiler-mode-in-intellij-idea-12-leda/\#comment-272265}}

\subsection{Инструмент \texttt{ccache}}
\texttt{ccache}\footnote{\url{http://ccache.samba.org/}}~--- это инструментальное средство разработки программного обеспечения, которое кэширует порождения C/C++ компиляции, так чтобы в следующий раз компиляции с теми же самыми параметрами и входными данными можно было избежать и взять результаты из кэша. Это позволяет значительно ускорить время перекомпиляции. Обнаружение повторов производится с помощью хэширования различных видов информации, которая должна быть уникальной для сеанса компиляции, и последующего использования хэш-сумм для идентификации кэшированных порождений. Поддерживаются языки C, C++, Objective-C и Objective-C++. Гарантируется, что такой подход безопасен (safe): важнейший аспект кэша компиляции~--- всегда возвращать в точности те же самые порождения, которые вернул бы настоящий компилятор. Это включает в себя предоставление точно тех же объектных файлов и предупреждений компиляции, которые были бы выданы настоящим компилятором.
Одной из возможностей \texttt{ccache} является совместное использование кэша. Группа разработчиков может увеличить hit rate кэша, совместно используя директорию, в которой он хранится. Возможно расположить кэш-директорию на сетевой файловой системе NFS (или похожей).
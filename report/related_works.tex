\section{Обзор}

\subsection[Утилита \texttt{make}]{Утилита \texttt{make}\footnote{http://ru.wikipedia.org/wiki/Make}}
\texttt{make}~--- утилита, автоматизирующая процесс преобразования файлов из одной формы в другую. Чаще всего это компиляция исходного кода в объектные файлы и последующая компоновка (linking) в исполняемые файлы или библиотеки. \texttt{make}~--- одна из самых широко распространённых утилит для отслеживания зависимостей, в значительной степени благодаря её включению в ОС Unix и ОС семейства BSD. Первая версия была создана Стюартом Фельдманом (Stuart Feldman) в 1977 году. Существует несколько версий \texttt{make}, основанных на оригинальной \texttt{make} или написанных с нуля, использующих те же самые форматы файлов и базовые принципы и алгоритмы, а также содержащие некоторые улучшения и расширения.

Утилита использует специальные \texttt{make}-файлы, в которых указаны зависимости файлов друг от друга и правила, определяющие действия для удовлетворения этих зависимостей. Решение о том, нужно ли перегенерировать целевые файлы (targets), принимается на основе информации о времени последнего изменения каждого файла. Если время последнего изменения исходных файлов или файлов-зависимостей больше соответствующего времени изменения целевых файлов, то \texttt{make} определяет и запускает необходимые программы для перегенерации целевых файлов, иначе сгенерированные ранее целевые файлы считаются актуальными (up-to-date). Таким образом, за счёт избежания избыточных перегенераций экономятся вычислительные ресурсы. Однако в случаях, когда файл меняется, а его время изменения остаётся в прошлом, такой подход даёт сбой, и пользователь должен принудительно запустить полную перекомпиляцию. Примерами таких случаев могут служить восстановление более старой версии исходного файла или ситуация, когда файлы находятся на сетевой файловой системе, чьё локальное время не синхронизировано с машиной, на которой запускается \texttt{make}. Соответственно, если время последнего изменения файла оказалось в будущем, то это вызовет избыточную перекомпиляцию. Кроме того, перекомпиляция (тоже, разумеется, избыточная) будет произведена, даже если изменение состояло, например, в модификации комментария внутри исходного файла.

\subsection{Инкрементальная компиляция в IntelliJ IDEA}
By default, IntelliJ IDEA compiles files on demand that is when you run the application or explicitly invoke the Make action. The rationale behind this choice is to preserve system resources for other tasks that can be more important at the moment.
The compilation in IntelliJ occurs through javac but the entire process is still guaranteed to incremental and then as fast as possible. IntelliJ IDEA, in fact, keeps track of the dependencies existing between source files and recompiles only files that have been modified. Files with compilation errors are highlighted, and so are the folders where such files are contained.

В текущей реализации инкрементальной компиляции в IntelliJ IDEA используется локальное кэширование, изменение файлов отслеживается по timestamp~--- для каждого файла запоминается время его самого позднего изменения на момент последней компиляции, и файл считается изменившимся, если фактическое время его самого позднего изменения не совпадает с запомненным. В кэше хранятся абсолютные пути к файлам, таким образом, при перемещении проекта или его части в другую директорию кэш теряется. В ситуации, когда разработчиков несколько, временные метки в силу их относительности использовать уже нельзя. Предлагается вместо них применять хэширование исходных файлов, а именно хэширующую структуру, способную считать контрольные суммы не только на уровне отдельных файлов, но и на уровне директорий и модулей проекта.

\subsection{Инкрементальная компиляция в Eclipse}
The Eclipse Platform distinguishes between full and incremental builds. Incremental builds are much faster than a complete rebuild of a project because only the resources that have changed since the last build need to be considered for compilation.

Incremental builders are invoked each time a file is saved. To prevent a bad user experience, take special care to make the incremental builder as fast as possible. To make a compiler fast, it helps to understand that in most compilers little time is spent in compilation at all. Most time is spent resolving the context of the program, such as the build classpath.

In the case of eScript, two kinds of information need to be discovered from the target environment:

    Starting with the Java classpath and the list of plug-ins referenced by a given script, the eScript compiler needs to find all possible external class types, as well as their methods and fields. This information is needed to determine whether a given input string refers to a class, an interface, a method, a field, or a local variable. 

    To facilitate the easy creation of the underlying Java class files for a given script, the eScript compiler, when it reads the contribution to a certain extension point, needs to interrogate the PDE to find out the class to extend or interface to implement. 

The overhead of building the context is surprisingly constant for eScript and dwarfs the memory consumption needed for compiling a script. The scripts tend to be small, but the universe of plug-ins is large. The eScript compiler easily loads about 14,000 classes, simply to bind strings to type names. Rebuilding this contexts adds about three to four seconds to a compilation. The compilation of the script itself is less than a second, and is hardly noticeable.

By not discarding the context information after a compilation, performance of the next compilation run is greatly improved. The first compilation will be slow, but the next ones will be non-interruptive. However, note that optimization is always a time/space trade-off. The price we pay for faster compilation is about 15 MB of state that needs to be cached. JDT suffers from the same dilemma. Load a big Java project and close all perspectives, including the Java perspective, and the entire Java model with its thousands of classes is being held onto by the JDT.

Incremental builders that are run sporadically may be wise to run a timer and clean up their cache after a certain expiration time to free up heap memory used by the platform. 

cite 

Eclipse and IntelliJ IDEA take a slightly different perspective of the process of compilation. In particular, Eclipse comes with its own compiler--Eclipse Compiler for Java or ECJ for short. ECJ differs from classic javac primarily because it allows for incremental builds from within the Eclipse IDE. In other words, all code is compiled as soon as you finish typing.
A feature of Eclipse that sometimes developers seem to miss in IntelliJ IDEA is compilation on every save. 

\subsection{Инструмент ccache}
ccache~--- это инструментальное средство разработки программного обеспечения, которое кэширует порождения C/C++ компиляции, так чтобы в следующий раз компиляции с теми же самыми параметрами и входными данными можно было избежать и взять результаты из кэша. Это позволяет значительно ускорить время перекомпиляции. Обнаружение повторов производится с помощью хэширования различных видов информации, которая должна быть уникальной для сеанса компиляции, и последующего использования хэш-сумм для идентификации кэшированных порождений. Поддерживаются языки C, C++, Objective-C и Objective-C++. Гарантируется, что подход безопасен: важнейщий аспект кэша компиляции~--- всегда возвращать в точности те же самые порождения, которые вернул бы настоящий компилятор. Это включает в себя предоставление точно тех же объектных файлов и предупреждений компиляции, которые были бы выданы настоящим компилятором. (cite: http://ccache.samba.org/)
Одной из возможностей ccache является совместное использование кэша. Группа разработчиков может увеличить hit rate кэша, совместно используя директорию, в которой он хранится. Возможно расположить кэш-директорию на сетевой файловой системе NFS (или похожей).
\section{Обзор}

\subsection{Инкрементальная компиляция в IntelliJ IDEA}
By default, IntelliJ IDEA compiles files on demand that is when you run the application or explicitly invoke the Make action. The rationale behind this choice is to preserve system resources for other tasks that can be more important at the moment.

The compilation in IntelliJ occurs through javac but the entire process is still guaranteed to incremental and then as fast as possible. IntelliJ IDEA, in fact, keeps track of the dependencies existing between source files and recompiles only files that have been modified. Files with compilation errors are highlighted, and so are the folders where such files are contained.
В текущей реализации инкрементальной компиляции в IntelliJ IDEA используется локальное кэширование, изменение файлов отслеживается по timestamp~--- для каждого файла запоминается время его самого позднего изменения на момент последней компиляции, и файл считается изменившимся, если фактическое время его самого позднего изменения не совпадает с запомненным. В кэше хранятся абсолютные пути к файлам, таким образом, при перемещении проекта или его части в другую директорию кэш теряется. В ситуации, когда разработчиков несколько, временные метки в силу их относительности использовать уже нельзя. Предлагается вместо них применять хэширование исходных файлов, а именно хэширующую структуру, способную считать контрольные суммы не только на уровне отдельных файлов, но и на уровне директорий и модулей проекта.

\subsection{Инкрементальная компиляция в Eclipse}
The Eclipse Platform distinguishes between full and incremental builds. Incremental builds are much faster than a complete rebuild of a project because only the resources that have changed since the last build need to be considered for compilation.

Incremental builders are invoked each time a file is saved. To prevent a bad user experience, take special care to make the incremental builder as fast as possible. To make a compiler fast, it helps to understand that in most compilers little time is spent in compilation at all. Most time is spent resolving the context of the program, such as the build classpath.

In the case of eScript, two kinds of information need to be discovered from the target environment:

    Starting with the Java classpath and the list of plug-ins referenced by a given script, the eScript compiler needs to find all possible external class types, as well as their methods and fields. This information is needed to determine whether a given input string refers to a class, an interface, a method, a field, or a local variable. 

    To facilitate the easy creation of the underlying Java class files for a given script, the eScript compiler, when it reads the contribution to a certain extension point, needs to interrogate the PDE to find out the class to extend or interface to implement. 


The overhead of building the context is surprisingly constant for eScript and dwarfs the memory consumption needed for compiling a script. The scripts tend to be small, but the universe of plug-ins is large. The eScript compiler easily loads about 14,000 classes, simply to bind strings to type names. Rebuilding this contexts adds about three to four seconds to a compilation. The compilation of the script itself is less than a second, and is hardly noticeable.

By not discarding the context information after a compilation, performance of the next compilation run is greatly improved. The first compilation will be slow, but the next ones will be non-interruptive. However, note that optimization is always a time/space trade-off. The price we pay for faster compilation is about 15 MB of state that needs to be cached. JDT suffers from the same dilemma. Load a big Java project and close all perspectives, including the Java perspective, and the entire Java model with its thousands of classes is being held onto by the JDT.

Incremental builders that are run sporadically may be wise to run a timer and clean up their cache after a certain expiration time to free up heap memory used by the platform. 

(cite: http://wiki.eclipse.org/FAQ_How_do_I_make_my_compiler_incremental%3F)

Eclipse and IntelliJ IDEA take a slightly different perspective of the process of compilation. In particular, Eclipse comes with its own compiler--Eclipse Compiler for Java or ECJ for short. ECJ differs from classic javac primarily because it allows for incremental builds from within the Eclipse IDE. In other words, all code is compiled as soon as you finish typing.
A feature of Eclipse that sometimes developers seem to miss in IntelliJ IDEA is compilation on every save. 

\subsection{Инструмент ccache}
ccache is a software development tool that caches the output of C/C++ compilation so that the next time, the same compilation can be avoided and the results can be taken from the cache. This can greatly speed up recompiling time. The detection is done by hashing different kinds of information that should be unique for the compilation and then using the hash sum to identify the cached output. Supported languages are C, C++, Objective-C and Objective-C++. It is safe. The most important aspect of a compiler cache is to always produce exactly the same output that the real compiler would produce. This includes providing exactly the same object files and exactly the same compiler warnings that would be produced if you use the real compiler. (cite: http://ccache.samba.org/)
Sharing a cache
A group of developers can increase the cache hit rate by sharing a cache directory. It is possible to put the cache directory on an NFS filesystem (or similar filesystems).

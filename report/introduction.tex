\input{preamble.tex}

\begin{document}

\chapter*{Введение}
Кэш компиляции~--- это некоторая структура данных, которая отражает мгновенное состояние проекта с точки зрения его реализации на низком уровне (например, для языка Java это совокупность класс-файлов плюс информация о зависимостях, соответствиях класс-файлов исходным файлам и т.д.). Такое хранилище может быть использовано (и используется в современных средах разработки) в процессе инкрементальной компиляции.

Инкрементальная компиляция представляет собой следующую оптимизацию процесса сборки проекта: вместо полной компиляции всего проекта с нуля перекомпилируются только изменённые со времени последней компиляции файлы, а также зависимые от них, на которые повлияли изменения (а также зависимые от них, и так далее~--- можно представить это как обход графа зависимостей в ширину). Например, если в одном из исходных файлов Java разработчик изменил значение \texttt{public static final} поля, то нужно перекомпилировать не только этот файл, но и все файлы, где есть использование этого поля, так как значение поля с такими модификаторами при компиляции подставляется в место его использования. В целях экономии вычислительных ресурсов информация о зависимостях подобного рода сохраняется в кэше компиляции, чтобы при следующем запуске сборки проекта можно было эффективно вычислять набор файлов, которые подлежат перекомпиляции. В этот же кэш попадают и класс-файлы~--- в случае, когда ни исходный файл, ни те файлы, от которых он зависит, не изменились со времени последней компиляции, ясно, что можно переиспользовать результат его последней компиляции~--- взять сохранённый класс-файл, вместо того чтобы тратить вычислительные ресурсы на компиляцию.

Кэш компиляции подвергается обновлению при каждой компиляции, чтобы находиться в актуальном состоянии, пригодном к использованию при следующем сеансе компиляции. Если над проектом работает несколько человек, у каждого из которых есть локальная рабочая копия репозитория, то у каждого нарастает свой локальный кэш компиляции, при этом б\'{о}льшая его часть у всех одинакова. В процессе такой коллективной разработки случаются ситуации, когда состояние проекта в локальной копии разработчика существенно отличается от состояния, для которого был посчитан его локальный кэш компиляции. Тогда инкрементальная компиляция теряет свои преимущества и мало чем отличается от процедуры полной сборки проекта с нуля. Примерами таких случаев могут служить cold start~--- сборка проекта в ситуации отсутствия кэша вообще~--- или переключение между ветками (``branches'')~--- например, основной и релизной ветками. Однако можно воспользоваться тем, что разработчиков всё-таки несколько и предложить способ переиспользования кэшей одних разработчиков другими, чтобы в таких ситуациях не приходилось каждый раз строить их с нуля.

В текущей реализации инкрементальной компиляции в IntelliJ IDEA используется локальное кэширование, изменение файлов отслеживается по timestamp~--- для каждого файла запоминается время его самого позднего изменения на момент последней компиляции, и файл считается изменившимся, если фактическое время его самого позднего изменения не совпадает с запомненным. В кэше хранятся абсолютные пути к файлам, таким образом, при перемещении проекта или его части в другую директорию кэш теряется. В ситуации, когда разработчиков несколько, временные метки в силу их относительности использовать уже нельзя. Предлагается вместо них применять хэширование исходных файлов, а именно хэширующую структуру, способную считать контрольные суммы не только на уровне отдельных файлов, но и на уровне директорий и модулей проекта.

Вопросы для исследования: Когда эффективно кэширование? Когда выгоднее компилировать с нуля? Что быстрее - передача по сети или локальная перекомпиляция? Нужны эксперименты: разные операционные системы, разные файловые системы, разные носители (HDD vs. SSD), разные размеры проектов, размеры данных, пересылаемых по сети.

В ходе работы... построена формальная модель, описывающая процесс и кэши компиляции, предложена и доказана гипотеза, реализован прототип, проведены эксперименты...

Полученные результаты... могут быть использованы также для задачи переиспользования индексов, используемых средами разработки для реализации интеллектуальных функций вроде ``Find Usages'', ``Find Implementations'', рефакторинга и т.п. Построение таких индексов с нуля для крупных проектов занимает достаточно много времени, поскольку требует обхода и чтения всех исходных файлов проекта. Используя идеи, сходные с упомянутыми для задачи переиспользования кэшей, можно добиться существенного сокращения времени построения этих индексов.

\end{document}
%\input{preamble.tex}

%\begin{document}

\section{Введение}
Сборка проекта в интегрированных средах разработки (Integrated Development Environment, IDE)~--- это процесс генерации низкоуровневых артефактов из исходных файлов высокого уровня (программного кода, ресурсов и т.п.) по правилам, описанным в проекте.

Кэш компиляции~--- это некоторая структура данных, которая отражает мгновенное состояние проекта с точки зрения его реализации на низком уровне (например, для языка Java это совокупность класс-файлов плюс информация о зависимостях, соответствиях класс-файлов исходным файлам и т.д.). Такое хранилище может быть использовано (и используется в современных средах разработки) в процессе инкрементальной компиляции.

Инкрементальная компиляция представляет собой следующую оптимизацию процесса сборки проекта: вместо полной компиляции всего проекта с нуля перекомпилируются только изменённые со времени последней компиляции файлы, а также зависимые от них, на которые повлияли изменения (а также зависимые от них, и так далее~--- можно представить это как обход графа зависимостей в ширину). Например, если в одном из исходных Java-файлов разработчик изменил сигнатуру некоторого метода, то нужно перекомпилировать не только этот файл, но и все файлы, где присутствует вызов этого метода (т.е. зависимые). В целях экономии вычислительных ресурсов информация о зависимостях подобного рода сохраняется в кэше компиляции, чтобы при следующем запуске сборки проекта можно было эффективно вычислять набор файлов, которые подлежат перекомпиляции. В этот же кэш попадают и класс-файлы~--- в случае, когда ни исходный файл, ни те файлы, от которых он зависит, не изменились со времени последней компиляции, ясно, что можно переиспользовать результат его последней компиляции~--- взять сохранённый класс-файл, вместо того чтобы тратить вычислительные ресурсы на компиляцию.

Кэш компиляции подвергается обновлению при каждой компиляции, чтобы находиться в актуальном состоянии, пригодном к использованию при следующем сеансе компиляции. Если над проектом работает несколько человек, у каждого из которых есть локальная рабочая копия репозитория, то у каждого ``нарастает'' свой локальный кэш компиляции, при этом б\'{о}льшая его часть у всех одинакова. В процессе такой коллективной разработки случаются ситуации, когда состояние проекта в локальной копии разработчика существенно отличается от состояния, для которого был посчитан его локальный кэш компиляции. Тогда инкрементальная компиляция теряет свои преимущества и мало чем отличается от процедуры полной сборки проекта с нуля. Примерами таких случаев могут служить ``cold start''~--- сборка проекта в ситуации отсутствия кэша вообще~--- или переключение между ветками (``branches'')~--- например, основной и релизной ветками. Однако можно воспользоваться тем, что разработчиков всё-таки несколько и предложить способ переиспользования кэшей одних разработчиков другими, чтобы в таких ситуациях не приходилось каждый раз строить их с нуля.

В данной работе предлагается такой способ переиспользования кэшей. Рассматривается главным образом процесс компиляции исходных файлов на языке Java, однако полученные результаты достаточно абстрактны, чтобы подход можно было применить к другим языкам программирования. Заметим, что подход применим не только к компиляции, но также и к другим вычислительно сложным процессам, которые получают на вход некоторый набор исходных файлов и выдают в качестве результата некоторый набор порождений (примером такого процесса может служить построение индексов).

%\end{document}
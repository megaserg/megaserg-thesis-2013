\section{Основные определения и аксиоматика}

Мы рассматриваем компиляцию как функцию, получающую на вход набор файлов, содержащих исходный код, и некоторый контекст. Контекст представляется в виде множества порождений. Возвращаемое значение функции, то есть результат компиляции~--- это тоже некоторое множество порождений. Здесь мы понимаем порождение не как класс-файл, а как некоторый неделимый атрибут, например, имя класса, поле класса, метод, элементарный тип и т.д. Это связано с тем, что в языках, подобных Java, наблюдаются зависимости разного рода; например, использование поля~--- совсем не то же самое, что вызов статического метода. При этом различные зависимости по-разному влияют на процесс инкрементальной компиляции при изменениях исходных файлов. К примеру, если разработчик изменил сигнатуру метода, то следует рассмотреть для перекомпиляции все файлы, где вызывался этот метод; однако если было изменено только тело метода, то такая модификация никак не могла затронуть другие файлы. Такой неоднородный граф зависимостей нельзя получить, сравнивая лишь содержимое файлов.

В полученных на вход исходных файлах могут содержаться упоминания-ссылки на такие атрибуты, определённые в других файлах, таким образом, для успешной компиляции соответствующие атрибуты должны быть представлены в контексте; в противном случае значение функции будет не определено (такую ситуацию назовём ``недоопределённостью''). Также возможен случай, когда в исходном файле определяется тот же самый атрибут, который уже представлен в контексте; в таком случае возникает неоднозначность, и значение функции будет не определено (такую ситуацию назовём ``переопределённостью''). Наконец, существуют вырожденные входы, значение функции на которых не определено ни в каком контексте.

Обозначим $\Sigma$~--- множество входов (исходных файлов), $\Omega$~--- множество выходов (порождений); эти множества не более чем счётны. Тогда частичная функция порождения выходов по входам (функция компиляции) будет выглядеть так:
$$gen : 2^\Omega \times 2^\Sigma \to 2^\Omega$$

Если $gen(\omega, \sigma) = \omega^\prime$, то будем говорить, что $\omega^\prime$~--- результат порождения входа $\sigma$ в контексте $\omega$. Это означает, что в результате компиляции набора исходных файлов в некотором состоящем из порождений-атрибутов контексте получается набор порождений-атрибутов. Успешной компиляции соответствует определённость функции на соответствующих входе и контексте, а неуспешной~--- неопределённость.

Для функции порождения был установлен следующий набор аксиом:

\begin{itemize}
	\item Аксиома о переопределённости: если $gen(\omega,\sigma)$~--- определена, то $$\omega \cap gen(\omega,\sigma) = \varnothing.$$
	Эта аксиома означает, что в результате процесса компиляции исходных файлов в каком-то контексте не может получиться ничего, что содержалось в этом контексте. Таким образом, при успешной компиляции невозможна ситуация неоднозначности, когда в исходном файле определяются атрибуты, которые уже были определены в других файлах и предоставлены в качестве контекста для компиляции.
	
	\item Аксиома о дизъюнктном разбиении: если $gen(\omega,\sigma) = \omega^\prime$, то существует единственное дизъюнктное разбиение $\omega^\prime=\bigcup^\varnothing_{s\in\sigma}\omega^\prime_s$, 
	удовлетворяющее свойству 

	$$\forall s\in\sigma : gen(\omega\cup\omega^\prime\setminus\omega^\prime_s,\{s\})=\omega^\prime_s.$$
	
	Эта аксиома означает, что для любого атрибута-порождения, получившегося в результате успешной компиляции, можно единственным образом указать исходный файл, в котором он был определён; при этом если в соответствии с этим принципом разделить все получившиеся атрибуты на множества, то каждое такое множество, состоящее из всех определённых в некотором исходном файле атрибутов, будет соответствовать результату успешной компиляции этого исходного файла в контексте, состоящем из всех остальных атрибутов и изначального контекста. Таким образом, всегда можно установить однозначное соответствие между результатами компиляции и исходными файлами, предоставленными на входе, то есть разделить результат компиляции на непересекающиеся множества, находящихся во взаимно однозначном соответствии с входными исходными файлами; также верно, что если выбрать один исходный файл и пополнить контекст порождениями всех остальных, то результат такой компиляции будет совпадать с подмножеством результата исходной компиляции, соответствующим этому исходному файлу.

	\item Аксиома о минимально необходимом контексте: если $gen(\omega,\{s\})$~--- определена, то в $\omega$ существует единственное наименьшее по включению подмножество $d_\omega(s)$, такое, что $gen(d_\omega(s), \{s\})$~--- определена. Эта аксиома означает, что в случае успешной компиляции в некотором контексте единственного исходного файла из этого контекста можно выделить такое подмножество, что компиляция будет успешной и при замене контекста на это подмножество; при этом если в качестве контекста взять любое собственное подмножество этого подмножества, компиляция будет неуспешной. Таким образом, для любого исходного файла существует минимально необходимый контекст, который, тем не менее, может быть разным в зависимости от изначального контекста.

	\item Аксиома о сужении контекста: если $gen(\omega,\{s\})$~--- определено, то для произвольного $\omega^\prime\subseteq\omega$, такого, что $d_\omega(s)\subseteq\omega^\prime$, $gen(\omega^\prime, \{s\})$ тоже определено и равно $gen(\omega,\{s\})$. Эта аксиома означает, что если в качестве контекста взять любое подмножество изначального контекста, содержащее минимально необходимый контекст, то компиляция будет успешной, более того, её результат совпадёт с результатом изначальной компиляции. Таким образом, результат компиляции не меняется при сужении контекста до тех пор, пока компиляция успешна.
	
	\item Аксиома о недоопределённости: если $gen(\omega, \sigma) = \omega^\prime$ и для $s \in \sigma$ существует $s_1 \in \sigma$, такой, что $$d_{\omega \cup \omega^\prime \setminus \omega^\prime_s}(s) \cap \omega^\prime_{s_1} \neq \varnothing,$$ то $gen(\omega, \sigma \setminus \{s_1\})$ не определена. Эта аксиома означает, что если при успешной компиляции в одном из входных исходных файлов используются атрибуты, определённые в другом входном исходном файле, то компиляция в том же контексте того же набора входов без этого второго файла будет неуспешной. Таким образом, имеют место не только зависимости исходных файлов от контекста, но и зависимости их друг от друга; если такая зависимость не удовлетворена, возникает ситуация недоопределённости.
	
	\item Аксиома о случаях неопределённости: если $gen(\omega, \{s\})$ не определено, то верно одно из следующих утверждений: a) имеет место ситуация недоопределённости; b) имеет место ситуация переопределённости; c) вход $\{s\}$ вырожденный, т.е. $\nexists \omega^\prime:$ $gen(\omega^\prime, \{s\})$ определено. Эта аксиома означает, что если компиляция неуспешна, то причиной этому может быть либо то, что не все требуемые зависимости исходного файла удовлетворены, либо то, что в исходном файле определяются уже определённые в контексте атрибуты, либо то, что файл не компилируется ни в каком контексте (например, содержит синтаксические ошибки).
\end{itemize}

Введём разбиение результата $gen(\omega, \sigma) = \omega^\prime$ на классы следующим образом. Класс $B^0_{\omega^\prime}$~--- это те порождения или части порождений, которые зависят только от входа $\sigma$. Класс $B^1_{\omega^\prime}$~--- те порождения или части порождений, которые зависят только от входа и порождений класса $B^0_{\omega}$ из контекста. По индукции, класс $B^i_{\omega^\prime}$~--- те порождения или части порождений, которые зависят только от входа и порождений классов $B^j_{\omega}$, где $j < i$.

Например, в языке Java к порождениям нулевого класса принадлежат имена классов и интерфейсов; объявления полей непримитивных типов и сигнатуры методов с непримитивными типами возвращаемого значения и аргументов принадлежат к порождениям первого класса, поскольку они используют классы и интерфейсы в качестве типов (а эти объявления принадлежат к нулевому классу); а вызовы методов с непримитивными типами будут принадлежать уже ко второму классу. Порождений выше второго класса, по нашему мнению, в Java нет~--- вызовы методов являются неименованными участками кода, поэтому от них зависеть ничего не может. В строгом доказательстве этого факта может помочь анализ синтаксиса и семантики Java.

\begin{itemize}	
	\item Аксиома об эквивалентных контекстах: $\forall s \in \Sigma,\; \forall \omega,\: \omega^\prime \subseteq \Omega:$ если $gen(\omega, \{s\})$ определено, то\\
	a) если $gen(\omega^\prime, \{s\})$ определено, то $$B^0_{gen(\omega, \{s\})} = B^0_{gen(\omega^\prime, \{s\})};$$
	b) если для $k \in \mathbb{N}$ $\forall i \in [0; k-1]$ $B^i_{\omega} = B^i_{\omega^\prime}$, то $gen(\omega^\prime, \{s\})$ определено и $$B^k_{gen(\omega, \{s\})} = B^k_{gen(\omega^\prime, \{s\})}.$$
	Эта аксиома означает, что при совпадении контекстов с точностью до $(k-1)$-го класса результат компиляции произвольного входа в этих контекстах совпадает с точностью до $k$-го класса. В дальнейшем для обозначения равенства с точностью до $k$-го класса будем использовать обозначение $=^k$: для $\omega_1, \omega_2 \subset \Omega$ запись $\omega_1 =^k \omega_2$ означает, что $\forall i \in [0; k]$ верно $B^i_{\omega_1} = B^i_{\omega_2}$.
\end{itemize}

Как видно, все аксиомы довольно естественны в том смысле, что каждая из них находит своё отражение в реалиях предметной области.\\

Приведём полезное следствие из аксиомы о дизъюнктном разбиении:

\textbf{Следствие.}
Если $gen(\omega, \sigma) = \omega^\prime$, то для любого $\tau \subseteq \sigma$ можно определить $\omega^\prime_\tau \defeq \bigcup\limits_{s\in\tau}\omega^\prime_s$, при этом
$$\tau_1 \cap \tau_2 = \varnothing \Rightarrow \omega^\prime_{\tau_1} \cap \omega^\prime_{\tau_2} = \varnothing$$

\textbf{Доказательство.} Пусть $\tau_1 \cap \tau_2 = \varnothing$, $\omega^\prime_{\tau_1} \cap \omega^\prime_{\tau_2} \neq \varnothing$. Тогда рассмотрим $x \in \omega^\prime_{\tau_1} \cap \omega^\prime_{\tau_2}$. По аксиоме о дизъюнктном разбиении $\exists ! s_x: x \in \omega^\prime_{s_x}$. Поскольку $x \in \omega^\prime_{\tau_1} = \bigcup\limits_{s\in\tau_1}\omega^\prime_s$, то $s_x \in \tau_1$. Аналогично $s_x \in \tau_2$. Следовательно, $\tau_1 \cap \tau_2 \neq \varnothing$. $\Box$\\

% --------------------------------------------------

Когда один и тот же набор исходных файлов компилируется в разных контекстах, результаты могут отличаться. Тем не менее, в силу того, что различные входные файлы зависят от предоставляемого при компиляции контекста по-разному, множества порождений, соответствующие отдельным файлам, могут совпадать, то есть не влиять напрямую на результат компиляции. Будем различать файлы, влияющие и не влияющие на результат компиляции. Для этого введём понятие дифференциала, которое поможет сформулировать теоремы об инкрементальной компиляции и о переиспользовании порождений. Дифференциал~--- это подмножество входа, содержащее только те файлы, которые влияют на результат компиляции.

\textbf{Определение.} Пусть $\omega$, $\tilde{\omega}$ --- множества порождений, $\sigma$ --- множество входов. Известно, что определены $gen(\omega, \sigma) = \omega^\prime$, $gen(\tilde{\omega}, \sigma) = \tilde{\omega}^\prime$. Тогда дифференциал $\partial\dfrac{\omega}{\tilde{\omega}}\sigma = \partial$ --- это наименьшее подмножество $\sigma$, удовлетворяющее свойству: 
$gen(\omega \cup \omega^\prime_{\partial}, \sigma\setminus\partial)$ и
$gen(\tilde{\omega} \cup \tilde{\omega}^\prime_{\partial}, \sigma\setminus\partial)$ либо одновременно не определены, либо одновременно определены и равны.\\

\textbf{Свойство 1}: $\partial$ всегда определён и в худшем случае равен $\sigma$. Это означает, что влияющее на результат компиляции подмножество можно выделить всегда; при этом, когда изменение контекста затронуло все файлы входного набора, это подмножество будет равно входному набору.\\

\textbf{Свойство 2}: $\partial\dfrac{\omega}{\omega}\sigma = \varnothing$. Это означает, что если контексты совпадают, то и результат компиляции не меняется, поэтому дифференциалу не принадлежит ни один файл.\\

\textbf{Лемма об эквивалентном дифференциале.} Пусть для некоторых $\sigma$, $\omega$, $\tilde{\omega}$ таких, что $gen(\omega, \sigma) = \omega^\prime$, $gen(\tilde{\omega}, \sigma) = \tilde{\omega}^\prime$, определён дифференциал $\partial = \partial\dfrac{\omega}{\tilde{\omega}}\sigma$. Пусть для некоторого $k \in \mathbb{N}$ и некоторого $\hat{\omega} \subset \Omega$ такого, что $gen(\hat{\omega}, \sigma) = \hat{\omega}^\prime$, верно $\hat{\omega} =^{k-1} \tilde{\omega}$. Тогда $$gen(\omega \cup \omega^\prime_\partial, \sigma\setminus\partial) =^k gen(\hat{\omega} \cup \hat{\omega}^\prime_\partial, \sigma\setminus\partial)$$

\textbf{Доказательство.}
$$\tilde{\omega} =^{k-1} \hat{\omega} \Rightarrow$$
$$\tilde{\omega}^\prime =^{k} \hat{\omega}^\prime \Rightarrow$$
$$\tilde{\omega}^\prime_\partial =^{k} \hat{\omega}^\prime_\partial \Rightarrow$$
$$\tilde{\omega} \cup \tilde{\omega}^\prime_\partial =^{k-1} \hat{\omega} \cup \hat{\omega}^\prime_\partial \Rightarrow$$
$$gen(\tilde{\omega} \cup \tilde{\omega}^\prime_\partial, \sigma\setminus\partial) =^{k} gen(\hat{\omega} \cup \hat{\omega}^\prime_\partial, \sigma\setminus\partial)$$
Но по определению дифференциала $gen(\tilde{\omega} \cup \tilde{\omega}^\prime_\partial, \sigma\setminus\partial) = gen(\omega \cup \omega^\prime_{\partial}, \sigma\setminus\partial)$. $\Box$\\

\begin{comment}
	Вопрос: верно ли, что в условиях инкрементального случая (там, где $\Delta^\rho_\alpha\sigma$)

	$$\partial\dfrac{\omega_\rho}{\omega_\alpha}(\sigma\setminus\rho)\subseteq\xi$$ ?

	\textbf{Доказательство:}

	\newcommand{\mypart}{\partial\dfrac{\omega_\rho}{\omega_\alpha}(\sigma\setminus\rho)}

	Докажем, что если $s \in \sigma\setminus\rho$, $s \notin \xi$, то $s \notin \mypart$. Обозначим $\tau = (\sigma\setminus\rho)\setminus\mypart$, тогда $\tau$ --- наибольшее подмножество $\sigma\setminus\rho$, такое, что $gen(\omega_\rho, \tau)$ определено $\Leftrightarrow$ $gen(\omega_\alpha, \tau)$ определено. Предположим, $s \in \mypart$, тогда $s \notin \tau$. Рассмотрим $gen(\omega_\rho, \tau)$.
\end{comment}
